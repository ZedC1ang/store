## Eureka-server模块

### Eureka-server模块开发

- 引入依赖
- 配置文件
- 启动注解

### Eureka-server模块知识点

- 为什么需要服务注册与发现
- IP变化
- 难以维护
- 改进

## 用户模块

### 用户模块知识点

- 登录
- 注册
- 重名校验
- 密码加密存储
- Session的使用
- 越权校验

### 用户模块开发

- 表设计
- 开发
- 测试

## 公共模块

### 公告模块知识点

- 常量、异常、工具类
- 自身不是Spring Boot项目

## 网关模块

### 网关模块知识点

- 为什么需要网关：可以完成统一的鉴权
- 签名校验、登录校验冗余问题
- Spring Cloud Zuul

### 登录功能分析

- 在单模块中，登陆状态需要保持
- Session的实现方案：登陆后，会保存用户信息到Session
- 之后的访问，会先从Session中获取用户信息，然后再执行业务逻辑
- 但是多模块下，有两层障碍，第一层网关，所以需要对网关进行配置
- 第二层是需要用到Redis共享Session的机制（原因：Session在单体模块时，存下来也是由单体模块来读取，但是多模块下别的模块是不能直接拿到的，需要中介即Redis提供支持，这样每个模块的Session会存储在Redis中，而不是对应的会话或服务器上，这样所有的模块都能共享，并能连接到同一个Redis中 ）
- EnableRedisHttpSession

## 商品模块

### 商品模块开发

- 表设计和接口设计

### 更新和新增商品

- 合并写法不可取
- 业务逻辑清晰、独立

### 批量上下架

- MyBatis遍历List
- where语句拼接

### 商品列表：搜索功能

- 入参判空
- 加%通配符
- like关键字

### 对于查询目录的in处理

- 目录处理：如果查某个目录下的商品，不仅是需要查出来该目录的，还需要查出来子目录下的所有商品
- 所以这里要拿到某一个目录ID下的所有子目录ID的List

### 前台：商品列表

- 排序功能
- MyBatis PageHelper
- 枚举：order by

## 阶段总结

- 重难点：模块拆分设计、公共模块、Zuul过滤器、Session处理、Feign调用
- 常见错误：模块粒度不合适、无公共模块、各接口独立校验、Session无法共享、HTTP手动调用

### 模块拆分

- 粒度：过粗、适中、过细
- 人员的角度
- 业务的角度：相关、独立

### Session处理

- 面试官提问：你的项目使用什么进行状态保存的？
- 回答：Session
- 面试官提问：Session在微服务的情况下有什么不同呢？
- 回答：Session在微服务的情况下就不能轻易的获取到了，所以我们可以利用共享Session的办法，把我们的Session存储到Redis中，而这个Redis，它对于各个模块而言都是同一个Redis，取到的数据也是同一份。所以有了Redis的帮助，我们的Session就可以实现共享，这样一来，不同的模块在存储和读取的时候也就实现了统一。这就是对于Session的处理。

## 购物车模块

- 表设计和接口设计
- 为什么在已经登陆的情况下，购物车模块中使用Feign调用用户模块的getUser方法依然获取不到当前的User？
- 这和内部调用的原理相关，假设请求实在网关里面，那自然没有问题，可以获取到。但是现在不一样，现在我们在购物车中去调用User的getUser方法，它是经过Feign的，而**Feign调用不经过网关**，所以Feign的调用是一种HTTP的调用，而之前从网关过来的那些请求头的重要信息，在默认的情况下都不会带过去。那我们要想让用户模块返回给我们当前用户信息，则必须把当前的Session相关的信息要告诉用户模块，也就是说，要在Feign调用的时候，**需要携带网关的Session信息**，这个信息的来源最开始是来自于网关，由网关携带传到购物车模块，再由购物车模块传给Feign，Feign在调用的时候传到用户模块，用户模块拿到相关信息才能正确的获取到当前用户，才能返回这个对象。可是现在既然Feign默认不把相关信息传出去，所以我们需要进行处理，处理的方法是加一个**FeignRequestInterceptor**，有了它之后就可以对每一个Feign发出的请求进行拦截。Feign在发出请求之前，经过这个拦截器的时候，我们会把所有的来自网关的相关信息都赋予到Feign的请求上，这样就不会发生信息的遗漏和丢失了。

### 业务流程

- 添加商品到购物车
- 1.判断商品是否在售+是否有库存
- 否：提示用户
- 是：2.判断该商品之前就在购物车里
- 否：添加新商品
- 是：原有基础上添加数量

## 订单模块

- 表设计和接口设计

### 订单状态

- 0 用户已取消
- 10 未付款（下单后初始状态）
- 20 已付款
- 30 已发货
- 40 交易完成

### 生成订单——用户下单

- 入参（收货人、收货地址、收获手机号）
- 从购物车中查找已经勾选的商品
- 判断商品是否正在售卖中
- 判断库存，保证不超卖
- **调用商品服务扣库存**
- 删除购物车中对应的商品
- 生成订单
- 订单号生成规则：随机生成订单号，而非简单的数字往上加，防止日订单量信息泄露
- 循环保存每个商品到order_item表

### 订单模块——下单流程

- 登录
- 浏览商品
- 加入购物车
- 下单
- 扫码支付/取消订单
- 发货
- 收货
- 订单完结

## 购物车和订单模块——重难点

- 订单表、订单状态设计：一定要有额外的订单编号字段以及订单状态字段
- 购物车流程：检查当前商品状态是否正常，即是否上架中以及库存够不够。并且在添加之前，如果已经商品已经在购物车了，那么应该改为更新数量，而不是新增一条记录
- 下单流程：拿到用户ID -> 从购物车查找以及勾选的商品 -> 如果购物车已勾选的为空，报错 -> 判断商品是否存在、上下架状态、库存 -> 把购物车对象转为订单Item对象 -> 扣库存 -> 把购物车中的已勾选商品删除 -> 生成订单 -> 生成订单号，有独立的规则 -> 插入到Order表 -> 循环保存每个商品到order_item表 -> 返回订单号
- Feign调用的处理：模块间Feign调用时，是默认不把Header信息带过去的，无法获取到用户信息。需要进行filter配置采用把所有Header进行转移的方法解决

## 购物车和订单模块——常见错误

- Feign调用取不到User对象
- URL误拦截：比如图片相关URL没有必要拦截
- 路由配置错误：最开始生成二维码的时候是没办法访问的，这是因为地址映射配置没有完善